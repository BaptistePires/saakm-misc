\section{Scheduler as a Kernel Module}
\label{sec:scheduler-as-a-kernel-module}

\par We now present \textit{Scheduler as a Kernel Module} (SaaKM), a framework that allows kernel developers to write schedulers as Linux kernel modules. Our main goal is to provide a way to write, test and deploy schedulers easily. To do so, we hide the complexity of the core scheduler (synchronization mecanisms, complex API) behind a set of functions corresponding to scheduling events that each policy must implement. We are also capable to have multiple policies loaded at the same time, allowing each applications to chose the scheduler that best fits its needs.

\paragraph{Design}
\par We rely on the \textit{sched\_class} API presented above to implement a minimal core scheduler (less than 1500 LoC) that will only be used to register policies and call the callbacks at the right places. \\ Each policy must implement a set of functions that map to specific scheduling events (e.g wakeup, scheduling tick, ...) and then register itself to our scheduling class.
\par{Events} The events are divided into two categories :
\begin{itemize}
        \item{Task events} are all events related to task, such as : a blocking task, a task waking up.
        \item{Core events} are all events related to the CPUs, such as : a scheduling tick, a CPU becoming idle.
\end{itemize}

In order to hide the complexity of the locks mecanisms and make it invisible to the user, we have to make the selection of a CPU and the actual enqueuing in two step. This is needed when a task \textit{p} is for waking up on CPU_0 but the scheduler decides that it should now run on CPU_1. Firstly, we need to lock CPU_0 to completly remove \textit{p} before we can enqueue it on CPU_1. \note{reecrire}