% !TEX root = ./main.tex

\section{Introduction}

\par CPU scheduling is a fundamental aspect of operating systems, crucial for both performance and security. Its significance has grown with the increasing complexity of hardware and the high concurrency of modern applications, which frequently utilize numerous threads\cite{hybridsched}. Linux provide a general purpose scheduler, Earliest Eligible Virtual Deadline First (EEVDF)\cite{eevdf} that is designed to handle those constraints. However, due to its genericity, it is not tailored to specific workloads and offers worse performance than application-targeted scheduling algorithms\cite{ghost,shenango}.

%This has led to the development of various specialized schedulers, such as MuQSS\cite{muqss} for desktop workloads, CFS\cite{cfs} for general purpose workloads, and BFS\cite{bfs} for low latency tasks. Additionally, research has produced schedulers optimized for specific environments, including real-time systems\cite{litmus}, data centers\cite{hermes}, and high-performance computing (HPC)\cite{slurm}. These specialized schedulers can significantly enhance performance for their intended use cases.

Writing a Linux scheduler is a highly complex endeavor. Beyond meeting performance requirements, it demands a thorough understanding of kernel APIs and interactions with numerous subsystems. The prevalence of multicore hardware introduces additional challenges, including concurrency, synchronization, and managing diverse execution contexts such as interrupts and preemption. These complexities pose substantial obstacles for developers aiming to modify or implement schedulers. Furthermore, any modification typically necessitates recompiling and redeploying the entire kernel, a process that is time-consuming. Errors in scheduler code can result in kernel crashes or data corruption, making debugging particularly challenging.

To address these challenges, several initiatives have emerged to make scheduler development easier, faster, and safer for kernel developers. Two main approaches exist. The first, exemplified by ghOSt\cite{ghost} and Skyloft\cite{skyloft}, enables users to implement schedulers in userspace by exposing scheduling data and providing communication channels between user and kernel space. The second approach focuses on in-kernel schedulers: sched\_ext\cite{schedext}, introduced in Linux v6.12, allows writing schedulers as eBPF\cite{ebpf} programs, while Enoki\cite{enoki} leverages Linux kernel modules to implement scheduling policies in Rust, which are then dynamically loaded into the kernel.

Existing solutions require developers to learn new languages such as Rust or master subsystems like eBPF, introducing a significant learning curve and altering established kernel development workflows. These approaches often restrict access to kernel APIs and internal data structures, limiting flexibility and integration with existing kernel components. To address these limitations, we propose SaaKM: a new approach that streamlines scheduler development by allowing developers to use familiar tools and workflows, prioritizing accessibility and seamless integration with the kernel rather than introducing new paradigms or languages. 

SaaKM abstracts thread management using a well-defined state machine, where scheduler behavior is driven by a set of explicit events. This approach enables a generic API—similar to the VFS abstraction for filesystems—that standardizes interactions between the kernel and scheduling policies. By clearly delineating control flow and access paths, SaaKM simplifies the implementation of new scheduling algorithms and enhances modularity. With SaaKM, new schedulers can be implemented as modules that are dynamically loaded into the kernel. Multiple schedulers can coexist, and processes can be flexibly assigned to different scheduling policies, allowing fine-grained control and optimization for diverse workloads.

In this paper, we first review the current approaches to scheduler development. We then introduce the design and implementation of SaaKM, our novel framework for writing scheduling policies as Linux kernel modules. Finally, we compare SaaKM with sched\_ext to assess their performance and usability.

% \par The introduction of sched\_ext\cite{schedext} in version v6.12 of the kernel aims to lower those barriers by providing a API to write schedulers using eBPF\cite{ebpf}. They do so by providing a set of helpers and hooks\note{pas sûr} to write scheduling policies that are injected at runtime and can be loaded/unloaded without the need to recompile and redploy the kernel.

% If you want to tweak it to better fit your workloads, you need to have a deep understanding of the core scheduler. Futhermore, the process to update, compile, deploy and test the new version is time consuming. That is why there are efforts to provide kernel developers ways to write, test and deploy schedulers faster. \newline
