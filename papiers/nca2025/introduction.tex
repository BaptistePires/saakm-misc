\section{Introduction}

\par CPU scheduling is a fundamental aspect of operating systems and plays a critical part regarding performances and security. With the increasing complexity of hardware and the diversity of workloads servers have to run, writing schedulers is tedious task. Linux provide a general purpose scheduler, Earliest Eligible Virtual Deadline First (EEVDF)\cite{eevdf} that is designed to handle those constraints. However, due to its genericity, it is not tailored to specific workloads and offers worse performance than application-targeted scheduling algorithms\cite{ghost,shenango}. \newline

\par Writing a Linux scheduler is complex task. On top of the performances constraints, it interracts with many parts of the kernel, requiring a deep understanding of the kernel APIs. Most schedulers are executed on multicore hardware, requiring to handle concurrency, synchronization and understanding the multiple contexts in which it can executes (interrupts, preempption). Those constraints create barrier for developers to modify or write schedulers. Furthermore, if you want to tweak your Linux scheduler, you have to recompile and redeploy the whole kernel which can be time consuming. Writing a scheduler with error will most likely end up in a kernel crash or causing data corruption, which can be quite tricky to debug and identify.\note{reformuler} \newline

\par This is why there are efforts to provide kernel developers easier, faster and safer way to write scheduling policies. There are two main approach to do so. ghOSt\cite{ghost} and Skyloft\cite{skyloft} both allow users to write schedulers that are executed in userspace. They do so by exposing the necessary scheduling data to userspace and implementing communications channels between the two. The second approach are schedulers executed in the kernel. sched\_ext\cite{schedext} was merged in the v6.12 of the Linux kernel and provide a way to to write schedulers as eBPF\cite{ebpf} programs. Enoki\cite{enoki} leverage the Linux kernel modules to write scheduling policies in Rust modules that are then loaded into the kernel.\newline

\par All of the current solutions require users to learn either a new language like Rust or a new subsystem like eBPF that can be seen as a constraint by developers. Our solution relies solely on linux kernel modules and the C langage which kernel developers are already familiar with. Our primary goal is to make writing schedulers easier and accessible to more developers, not to significantly increase performances.\newline

\par In this paper, we first present the state of the art for writing schedulers. Then we present the design and implementation of SaaKM, our contribution as an new way to write scheduling policies as Linux kernel modules. Finally, we compare SaaKM to sched\_ext to evaluate its performances and usability.\newline

% \par The introduction of sched\_ext\cite{schedext} in version v6.12 of the kernel aims to lower those barriers by providing a API to write schedulers using eBPF\cite{ebpf}. They do so by providing a set of helpers and hooks\note{pas s√ªr} to write scheduling policies that are injected at runtime and can be loaded/unloaded without the need to recompile and redploy the kernel.

% If you want to tweak it to better fit your workloads, you need to have a deep understanding of the core scheduler. Futhermore, the process to update, compile, deploy and test the new version is time consuming. That is why there are efforts to provide kernel developers ways to write, test and deploy schedulers faster. \newline
