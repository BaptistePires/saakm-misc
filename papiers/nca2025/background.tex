\section{Motivation and Background}

\par The scheduler is a critical part of an Operating System (OS) that manages the execution of processes. It has to take into account the hardware it runs on but also it might have to adapt to a lot of different workloads.
\par The scheduler is a critical part of an Operating system (OS) that manages the processes executions. It is required to take into account the hardware it runs on and it might need to adapt to a lot of different workloads. It is also tighly coupled with other parts of the OS like the memory management subsystem (especially regarding NUMA architectures), it therefore require a lot of knowledge to write and maintain a scheduler. When it comes to the Linux kernel, the Earliest Eligible Virtual Deadline First (EEVDF) scheduler is the default general purpose scheduler since v6.6. It is composed of 7000+ LoC alone and depends on a significant amount of C headers and kenel APIs. Because of its genericity it implements a lot of heuristics that can be hard to isolate and understand. It also causes a loss in performances in order to adapt to various workloads. \\


That is why there is an effort in the industry and academia to offer kernel developpers a way to write and test schedulers easily\note{ghost,schedext,plugsched}. This need motivated and allowed the successful merge in the kernel of \textit{sched\_ext} in the Linux version v6.12. \\
In this section, we will go through the current options that are available to kernel developer to write and test schedulers in the linux kernel. First, we will see the \textit{sched\_class} API of the Linux kernel, then we will take a look at Google proposition, ghOSt\cite{ghost-paper} that delegate scheduling decisions to user space. Then, we will see \textit{plugsched} a solution proposed by Alibaba, finally we will see \textit{sched\_ext} the latest solution proposed by Meta that has been merged into the Linux kernel.\note{ajouter un passage sur la liste des sched class}

\paragraph{The \textit{sched\_class} API}
\todo{tableau comme CSD avec +/- de chaque solutions ?}


\par Linux scheduler subsystem offers an API to write scheduler through its \textit{sched\_class} structure. It contains a set of function pointers that has to be implemented by the schedulers and we will be called in the right place by the scheduler core. You still need to modify some datastructures of the kernel like the \textit{task\_struct} (it represents a task) and the \textit{rq} (it represents a runqueue) to store data of your scheduler. This already represents a lot of work because you need to understand how the core of the scheduler (6000+ LoC) works, when and how to take locks and all of the other synchronization mecanisms used (RCU, memory syncrhonizations, ...). \\ Once you have implemented yout scheduler, you need to modify the linking file \textit{vmlinux.lds.h} to add your brand new scheduling class. This is what will allow the kernel to find it and register it with the others. The last step is to compile and boot your kernel, and only then, you will be able to test and debug it. \\ 
In short, writing a scheduler using the \textit{sched\_class} API is a long and tedious process that requires a wide and deep knowledge of the Linux kernel. \note{réecrire + restructurer un peu cette partie avec schedma sched class + avantages et inconvénients}

\paragraph{ghOSt - Userspace scheduling}

\par In order to match the evolution of their needs, Google needed a way to write, test and deploy schedulers easily. That is the main motivation behind ghOSt\cite{ghost-paper}. It delegates scheduling decisions to userspace and allows to deploy new schedulers or features without having to recompile and deploy kernel images. ghOst architecture is devided into two parts. The first one lies in the kernel, using a \textit{sched\_class} to implement the core of ghOSt and to define a rich API exposed to the userspace. The second part is executed in userspace and is composed of \textit{agents} which are scheduling policies. The two parts communicate through \textit{message queues} that allows the kernel to notify the agents of a thread state change, a scheduling tick. The agents now have all the information needed to make scheduling decisions and can commit \textit{transactions} via shared memory. \todo{presentation resultats + limitations}

\paragraph{plugsched - Live scheduler update}
\par Plugsched takes another approach to give users a way to tweak and modify the scheduler. It leverage the modularization of the Linux kernel by isolating the scheduler code into a \textit{Linux kernel module} that users can then modify, recompile and insert it into a running kernel. To do so, they rewrite the code sections of threads to redirect modified functions. \note{on est forcés de de passer tous les threads dans la nouvelle politique}

\paragraph{sched\_ext}
\par \textit{sched\_ext} is a proposition by Meta that has been merged into the Linux kernel mainline in v6.12. It offers a way to write schedulers as \textit{eBPF} programs. They rely on the \textit{eBPF} verifier to provide safety and security. The eBPF API allows to communicate with userspace program quite easily through \textit{maps}. In this case, it is used to delegate some scheduling work to the userspace, such as in the scheduler \textit{scx\_rusty} where they offload all of the load balancing logic to a userspace program written in Rust. This solution comes with limitations as you need to learn the eBPF API (which is still less time consuming than the core of the Linux scheduler) and you can be limited by the eBPF verifier.


\par As we have seen in this section, the need for a way to write, test and easily deploy new schedulers in the Linux kernel is a pressing issue. Each of the presented solutions have their own advantages and drawbacks