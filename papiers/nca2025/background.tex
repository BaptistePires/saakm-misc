\section{Motivation and Background}

\par The scheduler is a critical part of an Operating System (OS) that manages processes execution. It has to take into account the hardware it runs on but also have to adapt to a lot of different workloads. Currently, the general purpose scheduler of Linux is Earliest Eligible Virtual Deadline First (EEVDF) that has been introduced in v6.6. Being the default scheduler, it has to support a wide variety of workloads (e.g video encoding, web services,  ...) but this genericity comes with a cost. Firstly, il is composed of 7000+ LOC and depends heavily on other kernel APIs like the memory management subsystem, the synchronization mechanisms (e.g locks, RCU, ...). This make the development and maintenance quite complex for the kernel developers as you need to put a lot of time and effort to be able to understand the code. Being a core part of the kernel, modifying it requires you to recompile and redeploy your kernel, making the developemnt and debuging a time consuming process. That's why there are been efforts to provide kernel developers ways to write, test, debug and deploy schedulers easily. \\ \newline

% \note{ces trois points à bouger dans Saakm ?}

\par There has been an effort in recent years to provide such a solution. We can devide those in two main categories, the schedulers executing in userspace and the ones executing in kernel space. \\

\subsection{Userspace schedulers}
\par Userspace schedulers are executed outside of the kernel. They require a library to be linked against that will handle the communication with the kernel. \\

\par Google proposed ghOSt\cite{ghost} that is a framework to delegate scheduling decisions to userspace and deploy new scheduling policies without having to recompile and deploy kernel images. It is composed of two parts, the first one lies in the kernel and implement ghOSt core and define a rich API. The second part is executed in userspace and is composed of agents. Those agents then communicate with the core through message queues that allow the kernel to notify the agents of scheduling events, such as a thread state change. Agents can then commit transactions via shared memory. 
% \par The scheduler is a critical part of an Operating system (OS) that manages the processes executions. It is required to take into account the hardware it runs on and it might need to adapt to a lot of different workloads. It is also tighly coupled with other parts of the OS like the memory management subsystem (especially regarding NUMA architectures), it therefore require a lot of knowledge to write and maintain a scheduler. When it comes to the Linux kernel, the Earliest Eligible Virtual Deadline First (EEVDF) scheduler is the default general purpose scheduler since v6.6. It is composed of 7000+ LoC alone and depends on a significant amount of C headers and kenel APIs. Because of its genericity it implements a lot of heuristics that can be hard to isolate and understand. It also causes a loss in performances in order to adapt to various workloads. \\


% That is why there is an effort in the industry and academia to offer kernel developpers a way to write and test schedulers easily\note{ghost,schedext,plugsched}. This need motivated and allowed the successful merge in the kernel of \textit{sched\_ext} in the Linux version v6.12. \\
% In this section, we will go through the current options that are available to kernel developer to write and test schedulers in the linux kernel. First, we will see the \textit{sched\_class} API of the Linux kernel, then we will take a look at Google proposition, ghOSt\cite{ghost-paper} that delegate scheduling decisions to user space. Then, we will see \textit{plugsched} a solution proposed by Alibaba, finally we will see \textit{sched\_ext} the latest solution proposed by Meta that has been merged into the Linux kernel.\note{ajouter un passage sur la liste des sched class}


\subsection{Kernel schedulers}

\textbf{Scheduling class} Linux scheduler subsystem offers an API to write scheduler through its \textit{sched\_class} structure. It contains a set of function pointers that has to be implemented by the schedulers and we will be called in the right place by the scheduler core. You need to modifify some scheduler related datastructures to store data of your scheduler. This already represents a lot of work and time because you need to understand how the core of the scheduler (more than 6000 LOC) works. It heavily relies on complex synchronization mecanisms such as locks, Read-Copy-Update (RCU) and bariers due to the inherent concurrent nature of a multicore architecture. Once the scheduling class is implemented, you need to modifu the vmlinux.lds.h linking file to add your scheduling class. This allows the kernel to load and register it in its list, as shown in Figure \ref{fig:sched-classes} showing all of the current scheduling classes in the Linux knerel. You then need to modify the scheduler init function to modify some checks that ensures that all scheduling classes are loaded properly. Finally, you can compile and boot your kernel. Only then, you will be able to test and debug it. Writing a scheduler with the scheduling class API is a long and tedious process that requires a wide and deep knowledge of the Linux kernel that can be a barrier for developers.\\
% You still need to modify some datastructures of the kernel like the \textit{task\_struct} (it represents a task) and the \textit{rq} (it represents a runqueue) to store data of your scheduler. This already represents a lot of work because you need to understand how the core of the scheduler (6000+ LoC) works, when and how to take locks and all of the other synchronization mecanisms used (RCU, memory syncrhonizations, ...). \\ Once you have implemented your scheduler, you need to modify the linking file \textit{vmlinux.lds.h} to add your brand new scheduling class. This is what will allow the kernel to find it and register it with the others. The last step is to compile and boot your kernel, and only then, you will be able to test and debug it. Schedulers are sorted by priority order as seen in Figure \ref{fig:sched-classes}.\\ 
% In short, writing a scheduler using the \textit{sched\_class} API is a long and tedious process that requires a wide and deep knowledge of the Linux kernel. \note{réecrire + restructurer un peu cette partie avec schedma sched class + avantages et inconvénients}

\begin{figure}[htbp]
        \centering
        \includesvg[width=0.4\textwidth]{figures/linux-scheduling-class.svg}
        \caption{Linux scheduling classes overview}
        % \label{fig:linux-scheduling-class-svg}
\end{figure}


% \begin{figure}[htbp]
%         \centering
%         \begin{tikzpicture}[
%         node distance=.4cm,
%         schedclass/.style={
%                 rectangle,
%                 draw,
%                 minimum width=1cm,
%                 minimum height=0.5cm,
%                 align=center
%         },
%         font=\small
%         ]

%         % Nodes for scheduling classes
%         \node[schedclass] (stop) {STOP};
%         \node[schedclass, right=of stop] (dl) {DL};
%         \node[schedclass, right=of dl] (rt) {RT};
%         \node[schedclass, right=of rt] (fair) {FAIR};
%         \node[schedclass, right=of fair] (ext) {EXT};
%         \node[schedclass, right=of ext] (idle) {IDLE};

%         % Arrows to represent the linked list
%         \draw[->] (stop) -- (dl);
%         \draw[->] (dl) -- (rt);
%         \draw[->] (rt) -- (fair);
%         \draw[->] (fair) -- (ext);
%         \draw[->] (ext) -- (idle);

%         \end{tikzpicture}
%         \caption{Linux scheduling classes per priority order}
%         \label{fig:sched-classes}
% \end{figure}
% \par In order to match the evolution of their needs, Google needed a way to write, test and deploy schedulers easily. That is the main motivation behind ghOSt\cite{ghost-paper}. It delegates scheduling decisions to userspace and allows to deploy new schedulers or features without having to recompile and deploy kernel images. ghOst architecture is devided into two parts. The first one lies in the kernel, using a \textit{sched\_class} to implement the core of ghOSt and to define a rich API exposed to the userspace. The second part is executed in userspace and is composed of \textit{agents} which are scheduling policies. The two parts communicate through \textit{message queues} that allows the kernel to notify the agents of a thread state change, a scheduling tick. The agents now have all the information needed to make scheduling decisions and can commit \textit{transactions} via shared memory. \todo{presentation resultats + limitations}


\par \textbf{Plugsched - Live scheduler update} Plugsched takes another approach to give users a way to tweak and modify the scheduler. It leverage the modularization of the Linux kernel by isolating the scheduler code into a \textit{Linux kernel module} that users can then modify, recompile and insert it into a running kernel. To do so, they rewrite the code sections of threads to redirect modified functions. Once you have modified the extracted code, you can insert it. They do a data update during the insertion to migrate the data from previous scheduler version to the new one.\note{reformuler, on est forcés de de passer tous les threads dans la nouvelle politique}

\par \textbf{Enoki - } Enoki exposes 

\par \textbf{sched\_ext - eBPF schedulers} The ext scheduling class is a proposition by Meta that has been merged into the Linux kernel mainline in version v6.12. It offers a way to write schedulers as \textit{eBPF} programs. Their goal is to be capable of quickly test and tweak schedulers. The eBPF verifier provides securtiy and safety as it ensures that the program is correct before loading it. It can also be an issue because of the limitations it imposes, policies must heavily rely on helper functions that they define\note{retrouver la ref dans enoki je crois?}. The eBPF API allows to communicate with userspace program through maps, making it possible to delegate scheduling decisions to userspace. For instance, in their scheduler \textit{scx\_rusty}, where they offload all of the load balancing logic to a userspace program written in Rust.
% \paragraph{sched\_ext}
% \par \textit{sched\_ext} is a proposition by Meta that has been merged into the Linux kernel mainline in v6.12. It offers a way to write schedulers as \textit{eBPF} programs. They rely on the \textit{eBPF} verifier to provide safety and security. The eBPF API allows to communicate with userspace program quite easily through \textit{maps}. In this case, it is used to delegate some scheduling work to the userspace, such as in the scheduler \textit{scx\_rusty} where they offload all of the load balancing logic to a userspace program written in Rust. This solution comes with limitations as you need to learn the eBPF API (which is still less time consuming than the core of the Linux scheduler) and you can be limited by the eBPF verifier.\newline

\par There are others way to modify the scheduler in the kernel. kpatch\cite{} provide a way to live patch a running kernel but is restricted to function level. 
\par As we have seen in this section, the need for a way to write, test and easily deploy new schedulers in the Linux kernel is a pressing issue. Each of the presented solutions have their own advantages and drawbacks summarized in Table ?.